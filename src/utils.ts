import * as yaml from 'js-yaml';
import { YAML_TRANSLATER } from './constants.js';

export const translateYamlData = (data: Buffer): string => {
  let buffer = Buffer.from(data);

  for (const [from, to] of Object.entries(YAML_TRANSLATER)) {
    for (let i = 0; i < buffer.length; i++) {
      if (buffer[i] === parseInt(from, 10)) {
        buffer[i] = to;
      }
    }
  }

  const nullIndex = buffer.indexOf(0);
  if (nullIndex !== -1) {
    buffer = buffer.slice(0, nullIndex);
  }

  return buffer.toString('latin1');
};

// biome-ignore lint/suspicious/noExplicitAny: YAML data is dynamically typed
export const parseIRSDKYaml = (yamlStr: string): any => {
  let cleanStr = yamlStr.replace(/[\x00-\x08\x0B-\x0C\x0E-\x1F\x7F]/g, '');

  cleanStr = cleanStr.replace(
    /((?:DriverSetupName|UserName|TeamName|AbbrevName|Initials): )(.*)/g,
    (_match, prefix, value) => {
      const escaped = value.replace(/["\\\n]/g, (c: string) => `\\${c}`);
      return `${prefix}"${escaped}"`;
    },
  );

  cleanStr = cleanStr.replace(/(\w+: )(,.*)/g, '$1"$2"');

  try {
    // biome-ignore lint/suspicious/noExplicitAny: YAML data is dynamically typed
    return yaml.load(cleanStr) as any;
  } catch (error) {
    console.error('Failed to parse YAML:', error);
    return null;
  }
};

export const extractYamlSection = (
  sharedMem: Buffer,
  offset: number,
  len: number,
  sectionName: string,
): Buffer | null => {
  const start = offset;
  const end = start + len;

  const searchPattern = `\n${sectionName}:\n`;
  const searchBuffer = Buffer.from(searchPattern, 'utf-8');

  let matchStart = -1;
  for (let i = start; i < end - searchBuffer.length; i++) {
    let found = true;
    for (let j = 0; j < searchBuffer.length; j++) {
      if (sharedMem[i + j] !== searchBuffer[j]) {
        found = false;
        break;
      }
    }
    if (found) {
      matchStart = i + 1;
      break;
    }
  }

  if (matchStart === -1) {
    return null;
  }

  const endPattern = '\n\n';
  const endBuffer = Buffer.from(endPattern, 'utf-8');

  let matchEnd = end;
  for (let i = matchStart + 1; i < end - endBuffer.length; i++) {
    let found = true;
    for (let j = 0; j < endBuffer.length; j++) {
      if (sharedMem[i + j] !== endBuffer[j]) {
        found = false;
        break;
      }
    }
    if (found) {
      matchEnd = i;
      break;
    }
  }

  return sharedMem.slice(matchStart, matchEnd);
};

export const padCarNumber = (num: string | number): number => {
  const numStr = String(num);
  const numLen = numStr.length;
  let zero = numLen - numStr.replace(/^0+/, '').length;

  if (zero > 0 && numLen === zero) {
    zero -= 1;
  }

  const parsedNum = parseInt(numStr, 10);

  if (zero) {
    const numPlace = parsedNum > 99 ? 3 : parsedNum > 9 ? 2 : 1;
    return parsedNum + 1000 * (numPlace + zero);
  }

  return parsedNum;
};

export const checkSimStatus = async (): Promise<boolean> => {
  try {
    const response = await fetch(
      'http://127.0.0.1:32034/get_sim_status?object=simStatus',
      { signal: AbortSignal.timeout(5000) },
    );

    if (!response.ok) {
      return false;
    }

    const data = await response.text();
    return data.includes('running:1');
  } catch {
    return false;
  }
};
